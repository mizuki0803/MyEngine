#include "Medaman.h"
#include "Input.h"
#include "SpriteTextureLoader.h"
#include "BasePlayer.h"
#include "MedamanAvatarType01.h"
#include "MedamanAvatarType02.h"
#include "MedamanAvatarType03.h"
#include "MedamanAvatarType04.h"
#include "EnemyDefeatCounter.h"
#include "ParticleEmitter.h"

BasePlayer* Medaman::player = nullptr;
const float Medaman::appearModeTime = 600.0f;
const float Medaman::attackModeTime = 600.0f;
const float Medaman::waitModeTime = 500.0f;
const float Medaman::changeModeTime = 60.0f;
const float Medaman::returnBasePositionTime = 180.0f;

Medaman* Medaman::Create(const Vector3& position)
{
	//メダマーンのインスタンスを生成
	Medaman* medaman = new Medaman();
	if (medaman == nullptr) {
		return nullptr;
	}

	// 初期化
	if (!medaman->Initialize(position)) {
		delete medaman;
		assert(0);
		return nullptr;
	}

	return medaman;
}

bool Medaman::Initialize(const Vector3& position)
{
	//本体生成
	mainBody.reset(MedamanMainBody::Create(position));
	//メダマーン分身生成
	std::unique_ptr<MedamanAvatarType01> newAvatarType01;
	newAvatarType01.reset(MedamanAvatarType01::Create(mainBody.get(), { 2, 0, 0 }));
	avatars.push_back(std::move(newAvatarType01));
	std::unique_ptr<MedamanAvatarType02> newAvatarType02;
	newAvatarType02.reset(MedamanAvatarType02::Create(mainBody.get(), { -2, 0, 0 }));
	avatars.push_back(std::move(newAvatarType02));
	std::unique_ptr<MedamanAvatarType03> newAvatarType03;
	newAvatarType03.reset(MedamanAvatarType03::Create(mainBody.get(), { 0, 2, 0 }));
	avatars.push_back(std::move(newAvatarType03));
	std::unique_ptr<MedamanAvatarType04> newAvatarType04;
	newAvatarType04.reset(MedamanAvatarType04::Create(mainBody.get(), { 0, -2, 0 }));
	avatars.push_back(std::move(newAvatarType04));

	//HPを本体と分身の合計で算出する
	int maxHP = MedamanMainBody::GetMaxHP() + MedamanAvatar::GetMaxHP() * (int)avatars.size();
	HP = maxHP;

	//ビヘイビアツリー生成
	behaviorTree.reset(MedamanBehaviorTree::Create(this));

	return true;
}

void Medaman::Update()
{
	//死亡した分身の削除
	avatars.remove_if([](std::unique_ptr<MedamanAvatar>& avatar) {
		return avatar->GetIsDelete();
		});

	//更新
	mainBody->Update();//本体
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		avatar->Update();//分身
	}

	//ビヘイビアツリーによる行動遷移
	behaviorTree->Root();

	//HPUI更新
	if (hpUI) {
		hpUI->Update();
	}
	//ボス名表示UI更新
	if (bossNameUI) {
		bossNameUI->Update();
	}

}

void Medaman::Draw()
{
	//描画
	mainBody->Draw();//本体
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		avatar->Draw();//分身
	}
}

void Medaman::DrawLightCameraView()
{
	//影用光源ライトから見た視点での描画
	mainBody->DrawLightCameraView();//本体
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		avatar->DrawLightCameraView();//分身
	}
}

void Medaman::DrawTopLightCameraView()
{
	//頭上からの影用光源ライトから見た視点での描画
	mainBody->DrawTopLightCameraView();//本体
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		avatar->DrawTopLightCameraView();//分身
	}
}

void Medaman::DrawUI()
{
	//HPUI描画
	if (hpUI) {
		hpUI->Draw();
	}
	//ボス名表示UI描画
	if (bossNameUI) {
		bossNameUI->Draw();
	}
}

void Medaman::OnCollisionMainBody(const int damageNum, const Vector3& collisionPos, const Vector3& subjectVel)
{
	//待機状態ならダメージを喰らう
	const bool isWaitMode = (phase == Phase::Wait);
	//y軸角度45度以下ならダメージを喰らう
	const bool isDamageRota = (mainBody->GetRotation().y <= 45.0f);

	//本体が攻撃状態ならダメージを喰らうを追加し、どれか一つでも項目を達成していなければダメージを受けないで抜ける
	if (!(isMainBodyAttackMode && isWaitMode && isDamageRota)) { return; }

	//本体にダメージ
	mainBody->Damage(damageNum, collisionPos, subjectVel);

	//メダマーン全体にダメージ(メダマーン本体が実際に喰らったダメージ量をセット)
	const int mainBodyDamageNum = mainBody->GetDamageNum();
	Damage(mainBodyDamageNum);
}

void Medaman::OnCollisionAvatar(MedamanAvatar* avatar, const int damageNum, const Vector3& collisionPos, const Vector3& subjectVel)
{
	//分身が既に死亡していたら抜ける
	if (avatar->GetIsDead()) { return; }

	//待機状態ならダメージを喰らう
	const bool isWaitMode = (phase == Phase::Wait);
	//y軸角度45度以下ならダメージを喰らう
	const bool isDamageRota = (avatar->GetRotation().y <= 45.0f);

	//どちらか一つでも項目を達成していなければダメージを受けないで抜ける
	if (!(isWaitMode && isDamageRota)) { return; }

	//衝突した分身にダメージ
	avatar->Damage(damageNum, collisionPos, subjectVel);

	//分身が全滅したかチェック
	CheckAllAvatarDead();

	//メダマーン全体にダメージ(メダマーン分身が実際に喰らったダメージ量をセット)
	const int avatarBodyDamageNum = avatar->GetDamageNum();
	Damage(avatarBodyDamageNum);
}

bool Medaman::AppearModeCount()
{
	//登場状態でなければ抜ける
	if (!(phase == Phase::Appear)) { return false; }

	//タイマーを更新
	appearModeTimer++;

	//指定した時間になったらボス名表示UI生成
	const float bossNameUICreateTime = 160;
	if (appearModeTimer >= bossNameUICreateTime && !bossNameUI) {
		bossNameUI.reset(BossNameUI::Create(0));
	}

	//指定した時間になったらHPバー生成
	const float hpUICreateTime = appearModeTime - 100;
	if (appearModeTimer >= hpUICreateTime && !hpUI) {
		const Vector2 hpUIPosition = { 30, 170 };
		hpUI.reset(BossHPUI::Create(hpUIPosition, HP));
	}

	//タイマーが指定した時間になったら次のフェーズへ
	if (appearModeTimer >= appearModeTime) {
		phase = Phase::Attack;

		//分身のモデルを起きている状態のモデルに変更する
		for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
			avatar->ChangeModel();
		}

		//基準座標に戻る情報をセット
		SetReturnBasePosition();

		//ボス名表示UIはもう使用しないので解放しておく
		bossNameUI.reset();
	}

	return true;
}

bool Medaman::AppearFall()
{
	//降下にかかる時間
	const float fallTime = 400;
	//既に降下にかかる時間以上なら抜ける
	if (appearModeTimer > fallTime) { return false; }

	//イージング用に0〜1の値を算出する
	const float time = appearModeTimer / fallTime;

	//メダマーン本体を降下させる
	mainBody->Fall(time);

	return true;
}

bool Medaman::AttackModeCount()
{
	//攻撃状態でなければ抜ける
	if (!(phase == Phase::Attack)) { return false; }

	//タイマーを更新
	attackModeTimer++;

	//タイマーが指定した時間になったら次のフェーズへ
	if (attackModeTimer >= attackModeTime) {
		phase = Phase::Wait;

		//次に攻撃状態になったときのためにタイマーを初期化しておく
		attackModeTimer = 0;
		//攻撃内容を未設定にしておく
		attackType = AttackType::None;

		//攻撃状態終了するので必要な情報をセット
		AttackEnd();

		//攻撃状態を終えるのでfalseを返す
		return false;
	}

	return true;
}

bool Medaman::UpdateBulletShotPos()
{
	//攻撃状態でなければ抜ける
	if (!(phase == Phase::Attack)) { return false; }

	//本体と分身の発射座標を更新
	mainBody->UpdateBulletShotPos();
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		//分身が既に死亡していたら飛ばす
		if (avatar->GetIsDead()) { continue; }

		avatar->UpdateBulletShotPos();
	}

	return true;
}

bool Medaman::AttackTypeSelectStart()
{
	//攻撃内容が既に決まっていたらtrueを返す
	if (!(attackType == AttackType::None)) { return true; }

	//攻撃内容設定を開始するためfalseを返す
	return false;
}

bool Medaman::AttackTypeTrackingSelect()
{
	//本体が攻撃状態でなければ抜ける
	if (!isMainBodyAttackMode) { return false; }

	//前回の攻撃内容が追従だったら抜ける
	if (preAttackType == AttackType::Tracking) { return false; }

	//プレイヤー自機が画面左側にいたら抜ける
	if (player->GetPosition().x <= 0) { return false; }

	//攻撃内容:追従をセット
	attackType = AttackType::Tracking;
	//1つ前の攻撃内容を更新
	preAttackType = AttackType::Tracking;

	return true;
}

bool Medaman::AttackTypeSuperGiantBulletSelect()
{
	//本体が攻撃状態でなければ抜ける
	if (!isMainBodyAttackMode) { return false; }

	//前回の攻撃内容が超巨大弾だったら抜ける
	if (preAttackType == AttackType::SuperGiantBullet) { return false; }

	//攻撃内容:超巨大弾をセット
	attackType = AttackType::SuperGiantBullet;
	//1つ前の攻撃内容を更新
	preAttackType = AttackType::SuperGiantBullet;

	return true;
}

bool Medaman::AttackTypeRotateSelect()
{
	//本体が攻撃状態でなければ抜ける
	if (!isMainBodyAttackMode) { return false; }

	//前回の攻撃内容が回転だったら抜ける
	if (preAttackType == AttackType::Rotate) { return false; }

	//攻撃内容:回転をセット
	attackType = AttackType::Rotate;
	//1つ前の攻撃内容を更新
	preAttackType = AttackType::Rotate;

	return true;
}

bool Medaman::AttackTypeAvatarBodyBlowSelect()
{
	//本体が攻撃状態でなら抜ける
	if (isMainBodyAttackMode) { return false; }

	//前回の攻撃内容が分身体当たりだったら抜ける
	if (preAttackType == AttackType::AvatarBodyBlow) { return false; }

	//プレイヤー自機が画面右側にいたら抜ける
	if (player->GetPosition().x <= 0) { return false; }

	//攻撃内容:分身体当たりをセット
	attackType = AttackType::AvatarBodyBlow;
	//1つ前の攻撃内容を更新
	preAttackType = AttackType::AvatarBodyBlow;

	return true;
}

bool Medaman::AttackTypeAvatarGatlingSelect()
{
	//本体が攻撃状態でなら抜ける
	if (isMainBodyAttackMode) { return false; }

	//前回の攻撃内容が分身ガトリング砲だったら抜ける
	if (preAttackType == AttackType::AvatarGatling) { return false; }

	//攻撃内容:分身ガトリング砲をセット
	attackType = AttackType::AvatarGatling;
	//1つ前の攻撃内容を更新
	preAttackType = AttackType::AvatarGatling;

	return true;
}

bool Medaman::AttackTypeAvatarGiantBulletSelect()
{
	//本体が攻撃状態でなら抜ける
	if (isMainBodyAttackMode) { return false; }

	//前回の攻撃内容が分身巨大弾だったら抜ける
	if (preAttackType == AttackType::AvatarGiantBullet) { return false; }

	//攻撃内容:分身巨大弾をセット
	attackType = AttackType::AvatarGiantBullet;
	//1つ前の攻撃内容を更新
	preAttackType = AttackType::AvatarGiantBullet;

	return true;
}

bool Medaman::AttackTypeTracking()
{
	//攻撃内容が追従でなければ抜ける
	if (!(attackType == AttackType::Tracking)) { return false; }

	mainBody->AttackTypeTracking(player->GetWorldPos());

	return true;
}

bool Medaman::AttackTypeSuperGiantBullet()
{
	//攻撃内容が超巨大弾でなければ抜ける
	if (!(attackType == AttackType::SuperGiantBullet)) { return false; }

	mainBody->AttackTypeSuperGiantBullet();

	return true;
}

bool Medaman::AttackTypeRotate()
{
	//攻撃内容が回転でなければ抜ける
	if (!(attackType == AttackType::Rotate)) { return false; }

	mainBody->AttackTypeRotate();

	return true;
}

bool Medaman::AttackTypeAvatarBodyBlow()
{
	//攻撃内容が分身体当たりでなければ抜ける
	if (!(attackType == AttackType::AvatarBodyBlow)) { return false; }

	//本体と分身を攻撃内容:分身体当たりで動かす
	mainBody->AttackTypeAvatarBodyBlow();
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		//分身が既に死亡していたら飛ばす
		if (avatar->GetIsDead()) { continue; }

		avatar->AttackTypeAvatarBodyBlow(player->GetWorldPos());
	}

	return true;
}

bool Medaman::AttackTypeAvatarGatling()
{
	//攻撃内容が分身ガトリング砲でなければ抜ける
	if (!(attackType == AttackType::AvatarGatling)) { return false; }

	//本体と分身を攻撃内容:分身ガトリング砲で動かす
	mainBody->AttackTypeAvatarGatling(player->GetWorldPos());
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		//分身が既に死亡していたら飛ばす
		if (avatar->GetIsDead()) { continue; }

		avatar->AttackTypeAvatarGatling();
	}

	return true;
}

bool Medaman::AttackTypeAvatarGiantBullet()
{
	//攻撃内容が分身巨大弾でなければ抜ける
	if (!(attackType == AttackType::AvatarGiantBullet)) { return false; }

	//本体と分身を攻撃内容:分身巨大弾で動かす
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		//分身が既に死亡していたら飛ばす
		if (avatar->GetIsDead()) { continue; }

		avatar->AttackTypeAvatarGiantBullet();
	}

	return true;
}

bool Medaman::AttackModeMainBodyRota()
{
	//本体が攻撃状態でなければ抜ける
	if (!isMainBodyAttackMode) { return false; }

	//タイマーがモードチェンジ時間以下でないなら抜ける
	if (!(attackModeTimer < changeModeTime)) { return false; }

	//イージング用に0〜1の値を算出する
	const float time = attackModeTimer / changeModeTime;

	//攻撃状態にするため本体を回転させる
	mainBody->ChangeAttackMode(time);

	//ノックバックによってずれた座標を基準座標に移動させる
	mainBody->ReturnBasePosition(time);

	return true;
}

bool Medaman::AttackModeAvatarRota()
{
	//本体が攻撃状態でなら抜ける
	if (isMainBodyAttackMode) { return false; }

	//タイマーがモードチェンジ時間以下でないなら抜ける
	if (!(attackModeTimer < changeModeTime)) { return false; }

	//イージング用に0〜1の値を算出する
	const float time = attackModeTimer / changeModeTime;

	//攻撃状態にするため分身を回転させる
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		//分身が既に死亡していたら飛ばす
		if (avatar->GetIsDead()) { continue; }

		avatar->ChangeAttackMode(time);

		//ノックバックによってずれた座標を基準座標に移動させる
		avatar->ReturnBasePosition(time);
	}

	return true;
}

bool Medaman::WaitModeCount()
{
	//待機状態でなければ抜ける
	if (!(phase == Phase::Wait)) { return false; }

	//タイマーを更新
	waitModeTimer++;

	//タイマーが指定した時間になったら次のフェーズへ
	if (waitModeTimer >= waitModeTime) {
		phase = Phase::Attack;

		//次に待機状態になったときのためにタイマーを初期化しておく
		waitModeTimer = 0;

		//待機状態終了するので基準座標に戻る情報をセット
		SetReturnBasePosition();

		//待機状態を終えるのでfalseを返す
		return false;
	}

	return true;
}

bool Medaman::ReturnBasePosition()
{
	//タイマーが基準位置に戻るために要する時間以下でないなら抜ける
	const float timer = waitModeTimer - changeModeTime;
	if (!(timer < returnBasePositionTime)) { return false; }

	//イージング用に0〜1の値を算出する
	const float time = timer / returnBasePositionTime;

	//基準位置に戻す
	mainBody->ReturnBasePosition(time);
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		//分身が既に死亡していたら飛ばす
		if (avatar->GetIsDead()) { continue; }

		avatar->ReturnBasePosition(time);
	}

	return true;
}

bool Medaman::WaitModeMainBodyRota()
{
	//本体が攻撃状態でなければ抜ける
	if (!isMainBodyAttackMode) { return false; }

	//タイマーがモードチェンジ時間以下でないなら抜ける
	if (!(waitModeTimer < changeModeTime)) { return false; }

	//イージング用に0〜1の値を算出する
	const float time = waitModeTimer / changeModeTime;

	//待機状態にするため本体を回転させる
	mainBody->ChangeWaitMode(time);

	return true;
}

bool Medaman::WaitModeAvatarRota()
{
	//本体が攻撃状態でなら抜ける
	if (isMainBodyAttackMode) { return false; }

	//タイマーがモードチェンジ時間以下でないなら抜ける
	if (!(waitModeTimer < changeModeTime)) { return false; }

	//イージング用に0〜1の値を算出する
	const float time = waitModeTimer / changeModeTime;

	//待機状態にするため分身を回転させる
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		//分身が既に死亡していたら飛ばす
		if (avatar->GetIsDead()) { continue; }

		avatar->ChangeWaitMode(time);
	}

	return true;
}

bool Medaman::DeadExplosion()
{
	//死亡状態でなければ抜ける
	if (!(phase == Phase::Dead)) { return false; }
	//既に爆発回数が十分なら抜ける
	const int explosionNum = 12;
	if (explosionCount >= explosionNum) { return false; }

	//爆発演出発生タイマー更新
	const float explosionTime = 20;
	explosionTimer++;
	if ((explosionTimer % (int)explosionTime) == 0) {
		//爆発演出用パーティクル生成
		Vector3 particlePos = mainBody->GetWorldPos();
		const float distance = 8.0f;
		particlePos.x += (float)rand() / RAND_MAX * distance - distance / 2.0f;
		particlePos.y += (float)rand() / RAND_MAX * distance - distance / 2.0f;
		particlePos.z += (float)rand() / RAND_MAX * distance - distance / 2.0f;
		const float size = 2.0f;
		ParticleEmitter::GetInstance()->Explosion(particlePos, size);

		//爆発演出回数更新
		explosionCount++;

		//爆発が指定回数に達したら死亡フラグを立てる
		if (explosionCount >= explosionNum) {
			isDead = true;

			//倒した数カウンターを増やす(本体 + 分身数)
			const int defeatNum = 5;
			EnemyDefeatCounter::AddCounter(defeatNum);

			//本体のモデルを変更
			mainBody->ChangeDeadModel();
		}
	}

	//イージング用に0〜1の値を算出する
	const float backTime = 180;
	float time = explosionTimer / backTime;
	time = min(time, 1.0f);
	//メダマーン本体を基準の位置に戻す
	mainBody->DeadBasePosBack(time);

	return true;
}

bool Medaman::DeadFall()
{
	//死亡状態でなければ抜ける
	if (!(phase == Phase::Dead)) { return false; }

	//メダマーン本体に死亡時落下をさせる
	mainBody->DeadFall();

	//本体が削除状態なら削除
	if (mainBody->GetIsDelete()) {
		isDelete = true;
	}

	return true;
}

void Medaman::Damage(const int damageNum)
{
	//引数の数字の分ダメージを喰らう
	HP -= damageNum;

	//HPが0以下になったら死亡状態にする
	if (HP <= 0) {
		HP = 0;

		phase = Phase::Dead;
	}

	//ダメージを喰らったのでHPバーの長さを変更する
	if (hpUI) {
		hpUI->Damage(HP);
	}
}

void Medaman::CheckAllAvatarDead()
{
	//既に本体が攻撃状態なら抜ける
	if (isMainBodyAttackMode) { return; }

	//一体でも生きていたら抜ける
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		if (!avatar->GetIsDead()) {
			return;
		}
	}

	//本体を攻撃状態にする
	isMainBodyAttackMode = true;
	//本体のモデルを起きている状態のモデルに変更する
	mainBody->ChangeModel();
	//本体は待機中なので、待機状態にしておく
	phase = Phase::Wait;

	//攻撃内容を未設定にしておく
	attackType = AttackType::None;
	//攻撃状態で本体が攻撃する状態になってしまった場合のために攻撃状態タイマーを初期化しておく
	attackModeTimer = 0;
}

void Medaman::AttackEnd()
{
	//攻撃状態終了するので必要な情報をセット
	mainBody->AttackEnd();
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		//分身が既に死亡していたら飛ばす
		if (avatar->GetIsDead()) { continue; }

		avatar->AttackEnd();
	}
}

void Medaman::SetReturnBasePosition()
{
	//基準位置に戻るときの出発座標を記録する
	mainBody->SetReturnBasePosition();
	for (const std::unique_ptr<MedamanAvatar>& avatar : avatars) {
		//分身が既に死亡していたら飛ばす
		if (avatar->GetIsDead()) { continue; }

		//基準座標に戻す位置をセット
		avatar->SetReturnBasePosition();
	}
}
